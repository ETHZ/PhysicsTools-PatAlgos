#include "PhysicsTools/PatAlgos/interface/PATJetCleaner.h"
#include "DataFormats/Common/interface/ValueMap.h"

template<typename JetIn, typename JetOut>
pat::PATJetCleaner<JetIn,JetOut>::PATJetCleaner(const edm::ParameterSet & iConfig):
  jetSrc_(iConfig.getParameter<edm::InputTag>( "jetSource" )),
  helper_(jetSrc_),
  selectionCfg_(iConfig.getParameter<edm::ParameterSet>("selection"))
{
  // produces vector of electrons
  produces<std::vector<JetOut> >();
  // producers also backmatch to the electrons
  produces<reco::CandRefValueMap>();

  if (iConfig.exists("JetLikelihoodRejector")) {
    likelihoodRej_   = iConfig.getParameter<edm::InputTag>("JetLikelihoodRejector");
    doLikelihoodRej_ = true;
  } 
  else 
    doLikelihoodRej_ = false;
  
  if (iConfig.exists("removeOverlaps")) {
    overlapHelper_ = pat::helper::OverlapHelper(iConfig.getParameter< std::vector<edm::ParameterSet> >("removeOverlaps"));
  } 
  
  selector_ = std::auto_ptr<JetSelectorType >( 
                            new JetSelectorType(selectionCfg_) 
  			                     );
}


template<typename JetIn, typename JetOut>
pat::PATJetCleaner<JetIn,JetOut>::~PATJetCleaner() {
}


template<typename JetIn, typename JetOut>
void pat::PATJetCleaner<JetIn,JetOut>::produce(edm::Event & iEvent, const edm::EventSetup & iSetup) {     
  // start a new event
  helper_.newEvent(iEvent);

  typedef typename edm::Ref< std::vector<JetIn> > JetInRef;
  for (size_t idx = 0, size = helper_.srcSize(); idx < size; ++idx) {
    // read the source jet
    const JetIn & srcJet = helper_.srcAt(idx);

    // clone the jet and convert it to the new type
    JetOut ourJet = static_cast<JetOut>(srcJet);
 
    // perform the selection
    edm::Handle<pat::JetValueMap> LikelihoodRection;
    if (doLikelihoodRej_)
      iEvent.getByLabel(likelihoodRej_, LikelihoodRection); 
    if ( selector_->filter(idx,helper_.source(), &(*LikelihoodRection) ) ) continue;

    // write the jet
    helper_.addItem(idx, ourJet);
  }

  if (overlapHelper_.enabled()) {
     typedef typename pat::helper::OverlapHelper::Result Result;
     std::auto_ptr<Result> result = overlapHelper_.test( iEvent, helper_.selected() );
     for (size_t i = 0, n = helper_.size(); i < n; ++i) {
        helper_.setMark( i, (*result)[i] );
     }
  }

  helper_.done();
 
}

